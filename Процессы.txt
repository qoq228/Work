Настройка приложения провайдера
В данном разделе описаны процессы, которые происходят на этапе настройки провайдером своего приложения в маркетплейсе SberCRM.
Регистрация провайдера коммуникаций
Описание: процесс активации функциональности провайдера коммуникаций в админ-панели приложения провайдера в маркетплейсе, который автоматически создает базовую запись о провайдере в модуле коммуникаций и загружает первую версию конфигурации провайдера.
@startuml
actor "Разработчик провайдера" as Developer
participant "Маркетплейс" as Marketplace
participant "Модуль коммуникаций" as CommModule
database "База данных маркетплейса" as MarketplaceDB
database "База данных коммуникаций" as CommDB

Developer -> Marketplace: Установка галочки "Провайдер коммуникаций"
Marketplace -> MarketplaceDB: Обновление настроек приложения
MarketplaceDB --> Marketplace: Ok
Marketplace --> Developer: Страница загрузки конфигурации
Developer -> Marketplace: Загрузка JSON-файла с конфигурацией
Marketplace -> CommModule: Запрос на создание провайдера
CommModule -> CommDB: Создание записи в t_provider
CommDB --> CommModule: Ok
CommModule --> Marketplace: Подтверждение создания провайдера


Marketplace -> CommModule: Запрос на создание конфигурации
CommModule -> CommDB: Поиск провайдера по providerId
CommDB --> CommModule: Данные провайдера
CommModule -> CommDB: Создание записи в t_provider_configuration
CommDB --> CommModule: ID конфигурации
CommModule --> Marketplace: Успешное создание конфигурации
Marketplace --> Developer: Провайдер создан

@enduml
Процесс:
1.	Разработчик провайдера переходит в админ-панель своего приложения в маркетплейсе SberCRM и устанавливает галочку "Провайдер коммуникаций" в настройках доступов.
2.	Маркетплейс обновляет настройки приложения в своей базе данных, переводит пользователя на страницу загрузки конфигурации.
3.	Разработчик загружает json-файл на странице загрузки конфигурации провайдера коммуникаций в админ-панели своего приложения
4.	Маркетплейс автоматически отправляет запрос в модуль коммуникаций для регистрации провайдера POST /providers, передавая:
1.	appCode - код приложения в маркетплейсе
5.	Модуль коммуникаций проверяет переданные данные и создает запись о провайдере в своей базе данных в таблице t_provider:
1.	id - генерируется новый UUID
2.	code = appCode
6.	Модуль коммуникаций возвращает маркетплейсу идентификатор созданного провайдера.
7.	Маркетплейс автоматически отправляет запрос в модуль коммуникаций для загрузки/обновления конфигурации провайдера POST /provider-configurations, передавая:
1.	appCode - код приложения в маркетплейсе
2.	providerLabel - лейбл провайдера
3.	appVersion - версия приложения в маркетплейсе
4.	configurationVersion - версия конфигурации провайдера
5.	endpoints - объект с URL эндпоинтов провайдера в формате "Событие - Эндпоинт"
6.	authConfig - объект с параметрами аутентификации (по умолчанию API_KEY)
8.	Модуль коммуникаций валидирует обязательные эндпоинты, которые должны быть указаны в конфигурации:
1.	Обязательные: 
1.	getAccounts
2.	sendMessage
3.	updateMessageContent
4.	updateMessageStatus
5.	markChatSeen
6.	disconnectClient
2.	Необязательные
1.	setWebhook
2.	deleteWebhook
3.	getChatsHistory
4.	massMessageSend???
9.	Если все проверки пройдены успешно, модуль коммуникаций создаёт запись в таблице t_provider_configuration:
1.	id - генерируется новый UUID
2.	provider_id = ID созданного провайдера
3.	app_label = providerLabel
4.	app_code = appCode
5.	app_version = appVersion
6.	configuration_version = configurationVersion
7.	status = ACTIVE
8.	endpoints = endpoints
9.	auth_config = authConfig
10.	Модуль коммуникаций возвращает успешный ответ о сохранении конфигурации провайдера.
11.	Маркетплейс отображает разработчику сообщение об успешной установке провайдера и загрузке его конфигурации.
Получение конфигурации провайдера
Описание: процесс получения актуальной версии конфигурации провайдера, привязанной к версии его приложения
 @startuml
actor "Разработчик провайдера" as Developer
participant "Маркетплейс" as Marketplace
participant "Модуль коммуникаций" as CommModule
database "База данных коммуникаций" as CommDB

Developer -> Marketplace: Открыть страницу настроек конфигурации
Marketplace -> CommModule: Запрос  конфигурации
CommModule -> CommDB: Поиск  конфигурации для этой версии приложения
CommDB --> CommModule: Данные конфигурации
CommModule --> Marketplace: Данные конфигурации
Marketplace -> Developer: Данные конфигурации
@enduml 
Процесс: 
1.	Разработчик переходит на страницу настроек конфигурации провайдера коммуникаций в админ-панели своего приложения
2.	Маркетплейс автоматически отправляет запрос в модуль коммуникаций для получения информации о конфигурации провайдера для этой версии приложения GET /provider-configurations, передавая в query-параметрах:
1.	appCode - код приложения в маркетплейсе
2.	appVersion - версия приложения в маркетплейсе
3.	Модуль коммуникаций получает в БД коммуникаций активную версию конфигурации для этой версии приложения провайдера.
1.	Поиск по параметрам:
1.	app_code = appCode
2.	app_version = appVersion
3.	status = ACTIVE
4.	Модуль коммуникаций возвращает маркетплейсу конфигурацию.
Обновление конфигурации провайдера
Описание: процесс обновления конфигурации провайдера, включая эндпоинты API, версии и другие параметры, инициированный разработчиком провайдера. Конфигурация обновляется только относительно той версии приложения провайдера, которая передана в запросе. 
 @startuml
actor "Разработчик провайдера" as Developer
participant "Маркетплейс" as Marketplace
participant "Модуль коммуникаций" as CommModule
database "База данных коммуникаций" as CommDB

Developer -> Marketplace: Загрузка JSON-файла с новой конфигурацией
Marketplace -> CommModule: Запрос на обновление конфигурации
CommModule -> CommDB: Поиск существующей активной конфигурации для версии приложения
CommDB --> CommModule: Данные существующей активной конфигурации
CommModule -> CommModule: Проверка соответствия версии приложения
CommModule -> CommModule: Проверка обязательных эндпоинтов
alt Все проверки пройдены успешно
CommModule -> CommDB: Смена статуса активной конфигурации нна INACTIVE
CommDB --> CommModule: Ok
CommModule -> CommDB: Сохранение новой конфигурации со статусом ACTIVE
CommDB --> CommModule: Ok
CommModule --> Marketplace: Успешное обновление конфигурации
Marketplace --> Developer: Уведомление об успешном обновлении
else Ошибка проверки
CommModule --> Marketplace: Сообщение об ошибке с детализацией
Marketplace --> Developer: Уведомление об ошибке
end
@enduml
Процесс: 
1.	Разработчик загружает json-файл на странице загрузки конфигурации провайдера коммуникаций в админ-панели своего приложения
2.	Маркетплейс автоматически отправляет запрос в модуль коммуникаций для загрузки/обновления конфигурации провайдера POST /provider-configurations, передавая:
1.	appCode - код приложения в маркетплейсе
2.	providerLabel - лейбл провайдера
3.	appVersion - версия приложения в маркетплейсе
4.	configurationVersion - версия конфигурации провайдера
5.	endpoints - объект с URL эндпоинтов провайдера в формате "Событие - Эндпоинт"
6.	authConfig - объект с параметрами аутентификации (по умолчанию API_KEY)
3.	Модуль коммуникаций получает в БД коммуникаций активную версию конфигурации для этой версии приложения провайдера.
1.	Поиск по параметрам:
1.	app_code = appCode
2.	app_version = appVersion
3.	status = ACTIVE
4.	Модуль коммуникаций проверяет, что версия новой конфигурации больше версии полученной активной конфигурации
5.	Модуль коммуникаций валидирует эндпоинты, которые должны быть указаны в конфигурации:
1.	Обязательные: 
1.	getAccounts
2.	sendMessage
3.	updateMessageContent
4.	updateMessageStatus
5.	markChatSeen
6.	disconnectClient
2.	Необязательные
1.	setWebhook
2.	deleteWebhook
3.	getChatsHistory
4.	massMessageSend???
6.	Если все проверки пройдены успешно, модуль коммуникаций переводит полученную активную версию конфигурации в статус INACTIVE
7.	Модуль коммуникаций создаёт запись в таблице t_provider_configuration:
1.	id - генерируется новый UUID
2.	provider_id = наследуется от последней активной версии конфигурации
3.	app_label = providerLabel
4.	app_code = наследуется от последней активной версии конфигурации
5.	app_version = наследуется от последней активной версии конфигурации
6.	configuration_version = configurationVersion
7.	status = ACTIVE
8.	endpoints = endpoints
9.	auth_config = authConfig
8.	Модуль коммуникаций возвращает успешный ответ об обновлении конфигурации провайдера.
9.	Маркетплейс отображает разработчику сообщение об успешном обновлении конфигурации для этой версии приложения.
Создание новой версии приложения провайдера
Описание: процесс создания новой версии приложения провайдера. По событию создания новой версии приложения, модуль коммуникаций должен создать конфигурацию провайдера для этой версии приложения. Берется активная конфигурация прошлой версии приложения. Процесс не проводится для создания первой версии приложения
 @startuml
actor "Разработчик провайдера" as Developer
participant "Маркетплейс" as Marketplace
participant "Модуль коммуникаций" as CommModule
database "База данных коммуникаций" as CommDB

Developer -> Marketplace: Создать новую версию приложения
Marketplace -> Marketplace: Создание новой версии приложения
Marketplace --> Developer: Ok
Marketplace -> CommModule: Создана новая версия приложения
CommModule -> CommDB: Поиск  активной конфигурации \nдля последней версии приложения
CommDB --> CommModule: Данные конфигурации
CommModule -> CommDB: Сохранить конфигурацию для новой версии приложения
CommDB --> CommModule: Ok
CommModule --> Marketplace: Ok
@enduml

 
Процесс:
1.	Разработчик в админ-панели своего приложения нажимает "+Добавить версию".
2.	Маркетплейс создает новую версию приложения.
3.	Маркетплейс автоматически отправляет запрос в модуль коммуникаций для передачи события создания новой версии приложения провайдера POST /providers/version-update, передавая:
1.	appCode - код приложения в маркетплейсе
2.	newAppVersion - новая версия приложения в маркетплейсе
4.	Модуль коммуникаций получает в БД коммуникаций активную версию конфигурации для прошлой версии приложения провайдера.
5.	Модуль коммуникаций создает в t_provider_configuration новую запись:
1.	id - генерируется новый UUID
2.	app_version = newAppVersion
3.	Все остальные поля копируются с полученной активной конфигурации
6.	Модуль коммуникаций возвращает успешный ответ о создании конфигурации провайдера для новой версии приложения.
Настройки тенанта
Установка приложения тенанту
Описание: процесс установки приложения провайдера коммуникаций на тенант в маркетплейсе SberCRM.
@startuml
actor "Администратор тенанта" as Admin
participant "Маркетплейс" as Market
participant "Модуль коммуникаций" as Comm
database "БД коммуникаций" as DB

Admin -> Market: Установка приложения
Market -> Comm: Запрос на создание связки
Comm -> DB: Поиск конфигурации для версии приложения
DB --> Comm: Данные конфигурации
Comm -> DB: Создание записи в t_tenant_provider_connection
DB --> Comm: Ok
Comm --> Market: Подтверждение создания связки
Market --> Admin: Уведомление об успешной установке
@enduml
Процесс:
1.	Администратор тенанта устанавливает приложение провайдера в маркетплейсе SberCRM.
2.	Маркетплейс отправляет запрос в модуль коммуникаций для создания связки "тенант - версия конфигурации" POST /tenant-configurations, передавая:
1.	externalTenantId -  внешний ID тенанта (в заголовке)
2.	appCode - код приложения
3.	appVersion - версия устанавливаемого приложения
3.	Модуль коммуникаций находит активную конфигурацию для указанной версии приложения.
4.	Модуль коммуникаций находит ID тенанта в таблице тенантов
1.	Поиск по external_id = externalTenantId
5.	Модуль коммуникаций создает запись в таблице t_tenant_provider_connection, связывая тенанта с найденной конфигурацией.
6.	Модуль коммуникаций возвращает успешный ответ об успешном создании связки.
7.	Маркетплейс отображает уведомление об успешной установке приложения.
Обновление версии приложения у тенанта
Описание: процесс обновления версии приложения провайдера тенантом в маркетплейсе SberCRM.
@startuml
actor "Администратор тенанта" as Admin
participant "Маркетплейс" as Market
participant "Модуль коммуникаций" as Comm
database "БД коммуникаций" as DB

Admin -> Market: Обновление приложения
Market -> Comm: Запрос на обновление связки
Comm -> DB: Поиск конфигурации для новой версии
DB --> Comm: Данные конфигурации
Comm -> DB: Обновление записи в t_tenant_provider_connection
DB --> Comm: Ok
Comm --> Market: Подтверждение обновления связки
Market --> Admin: Уведомление об успешном обновлении
@enduml
Процесс:
1.	Администратор тенанта обновляет приложение провайдера в маркетплейсе SberCRM.
2.	Маркетплейс отправляет запрос в модуль коммуникаций для обновления связки "тенант - версия конфигурации" PATCH /tenant-configurations, передавая:
1.	externalTenantId -  внешний ID тенанта (в заголовке)
2.	appCode - код приложения
3.	appVersion - версия устанавливаемого приложения
3.	Модуль коммуникаций находит активную конфигурацию для новой версии приложения.
4.	Модуль коммуникаций находит ID тенанта в таблице тенантов
1.	Поиск по external_id = externalTenantId
5.	Модуль коммуникаций обновляет запись в таблице t_tenant_provider_connection, связывая тенанта с новой конфигурацией.
6.	Модуль коммуникаций возвращает успешный ответ об успешном создании связки.
7.	Маркетплейс отображает уведомление об успешном обновлении приложения.
Отключение приложения у тенанта
Описание: процесс удаления приложения провайдера у тенанта.
@startuml
actor "Администратор тенанта" as Admin
participant "Маркетплейс" as Market
participant "Модуль коммуникаций" as Comm
database "БД коммуникаций" as DB

Admin -> Market: Удаление приложения
Market -> Comm: Запрос на удаление связки
Comm -> DB: Поиск связки
DB --> Comm: Данные связки
Comm -> Comm: Деактивация токена провайдера
Comm -> DB: Удаление записи
DB --> Comm: Ok
Comm --> Market: Подтверждение удаления
Market --> Admin: Уведомление об успешном удалении
@enduml


Процесс:
1.	Администратор тенанта удаляет приложение провайдера в маркетплейсе SberCRM.
2.	Маркетплейс отправляет запрос в модуль коммуникаций для удаления связки "тенант - версия конфигурации" DELETE /tenant-configurations передавая:
1.	externalTenantId -  внешний ID тенанта (в заголовке)
2.	appCode - код приложения (в query-параметрах)
3.	Модуль коммуникаций находит ID тенанта в таблице тенантов
1.	Поиск по external_id = externalTenantId
4.	Модуль коммуникаций находит связку для указанного тенанта и приложения.
1.	Поиск по фильтру:
1.	tenant_id = tenant_id, найденный по externalTenantId
2.	provider_id = id провайдера, у которого t_provider.code = appCode
5.	Модуль коммуникаций поводит процедуру деактивации токена провайдера.
1.	При деактивации токена модуль коммуникаций должен отправить запрос на URL провайдера, который он указал в своей конфигурации в endpoints.disconnectClient
6.	Модуль коммуникаций удаляет запись из таблицы t_tenant_provider_connection.
7.	Маркетплейс отображает уведомление об успешном удалении приложения.
Публичный API
В данном разделе описаны процессы, которые происходят в модуле коммуникаций после подключения пользователем приложения провайдера и активации токена. Данные методы публичного API использует провайдера для передачии в модуль коммуникаций той или иной информации.
Получение нового сообщения от провайдера
Описание: процесс обработки сообщений, инициированный провайдером. Включает получение текстовых сообщений, сообщений с вложенными файлами, создание новых чатов и участников. В каждом сообщении провайдер передает полную информацию о чате и его участниках. Если не удается найти отправителя в списке участников чата - сервис коммуникаций создает нового участника чата с информацией из запроса.
@startuml
Participant "Provider" as pr
Participant "Communications.Back" as cb
Database "Communications DB" as cdb
Participant "Communications.Front" as cf

pr -> cb: Новое сообщение
cb -> cb: Проверка токена

alt Если токен не верный
cb --> pr: Неверный токен
else Если токен верный

alt Если чата не существует
cb -> cdb: Создать чат
cdb --> cb: Ok

loop Для каждого полученного участника чата
cb -> cdb: Создать участников чата
cdb --> cb: Ok
end
end

alt Если сообщение текстовое
cb -> cdb: Сохранить сообщение
cdb --> cb: Ok
else Если сообщение с вложением
cb -> cdb: Сохранить сообщение
cdb --> cb: Ok
cb -> cdb: Сохранить вложение
cdb --> cb: Ok
end

cb --> pr: Сообщение обработано
cb --> cf: Новое сообщение

end
@enduml
Процесс:
1.	Провайдер направляет в Public API запрос на новое сообщение POST /messages
2.	Модуль коммуникаций получает этот запрос, проверяет полученный токен
3.	Модуль коммуникаций ищет в БД чатов чат, у которого external_id = chat.chatId
4.	Если такой чат находится:
1.	Модуль коммуникаций производит сохранение этого сообщения в БД сообщений:
1.	t_message.id - генерируется новый UUID
2.	 t_message.tenant_id = id тенанта, к которому привязан токен в заголовке запроса
3.	t_message.chat_id = id чата, у которого t_chat.external_id = chatId
4.	t_message.sender_id = id участника чата, у которого t_member.external_id = sender.id
5.	t_message.external_id = messageId
6.	t_message.content = content (пусто, если type != text)
7.	t_message.type = type
8.	t_message.delivery_status = "delivered"
9.	t_message.seen_flag = false
10.	t_message.incoming_flag = true
11.	t_message.edited_flag = false
12.	t_message.deleted_flag = false
13.	t_message.source_type = "provider"
14.	t_message.system_flag = false
15.	t_message.sent_at = sentAt
2.	Если тип сообщение - "файл" (type = file), модуль коммуникаций также сохраняет запись о вложении в БД вложений (сам файл не сохраняется в file-storage):
1.	t_attachment.id = генерируется новый UUID
2.	t_attachment.message_id = t_message.id
3.	t_attachment.tenant_id = t_message.tenant_id
4.	t_attachment.name = attachment.name
5.	t_attachment.size = attachment.size
6.	t_attachment.internal_content_url = не заполняется
7.	t_attachment.provider_content_url = attachment.link
8.	t_attachment.file_extension = attachment.fileExt
5.	Если такой чат не найден:
1.	Модуль коммуникаций создает чат:
1.	t_chat.id = генерируется UUID
2.	t_chat.tenant_id = id тенанта, к которому привязан токен в заголовке запроса
3.	t_chat.account_id = id аккаунта тенанта, который связан с каналом чата channel
4.	t_chat.external_id = chat.chatId
5.	t_chat.name = name
6.	t_chat.type = type
7.	t_chat.custom_name_flag = false
8.	t_chat.colour_generate_marker = генерируется на основе имени чата или ID
9.	t_chat.unread_messages_count = 1
10.	t_chat.last_message_id = id созданного сообщения (после создания)
2.	Модуль коммуникаций создает участников чата:
1.	t_member.id = генерируется новый UUID
2.	t_member.tenant_id = id тенанта (только для внутренних участников, для клиентов NULL)
3.	t_member.account_id = id аккаунта (только для внутренних участников, для клиентов NULL)
4.	t_member.external_id = member.id
5.	t_member.name = member.name
6.	t_member.email = member.email
7.	t_member.phone = member.phone
8.	t_member.username = member.username
9.	t_member.client_flag = true для внешних участников, false для внутренних
3.	Модуль коммуникаций создает связь между участниками чата и чатом:
1.	t_chat_member.id = генерируется новый UUID
2.	t_chat_member.member_id = id созданного участника
3.	t_chat_member.chat_id = id созданного чата
4.	Модуль коммуникаций добавляет в чат сообщение по процедуре из п.4
Обновление сообщения от провайдера
Описание: процесс изменения текста ранее отправленного сообщения, инициированный провайдером. Для сообщений с type != text данный метод использовать нельзя.
@startuml
Participant "Provider" as pr
Participant "Communications.Back" as cb
Database "Communications DB" as cdb
Participant "Communications.Front" as cf

pr -> cb: Обновленное сообщение
cb -> cb: Проверка токена

alt Если токен не верный
cb --> pr: Неверный токен
else Если токен верный

alt Если сообщение текстовое
cb -> cdb: Обновить текст сообщения
cdb --> cb: Ok
cb --> pr: Сообщение обработано
cb --> cf: Сообщение обновлено
else Если сообщение не текстовое
cb --> pr: Ошибка - можно обновлять только текстовые сообщения
end

end
@enduml

Процесс:
1.	Провайдер направляет в Public API коммуникаций запрос на обновление сообщение PATCH /messages/{messageId}
2.	Модуль коммуникаций получает этот запрос, проверяет полученный токен
3.	Модуль коммуникаций производит поиск сообщения в БД сообщений:
1.	Найти сообщение, messageId которого равен t_message.external_id и chatId равен t_message.chat.external_id
4.	Если сообщение найдено и его тип "text", модуль коммуникаций обновляет сообщение:
1.	t_message.content = content
2.	t_message.edited_flag = true
5.	Модуль коммуникаций направляет на фронт инфо о том, что сообщение обновлено
Обновление статуса сообщения от провайдера
Описание: процесс актуализации статуса сообщения, инициированный провайдером.
@startuml
Participant "Provider" as pr
Participant "Communications.Back" as cb
Database "Communications DB" as cdb
Participant "Communications.Front" as cf

pr -> cb: Обновленный статус сообщения
cb -> cb: Проверка токена

alt Если токен не верный
cb --> pr: Неверный токен
else Если токен верный

cb -> cdb: Обновить статус сообщения
cdb --> cb: Ok
cb --> pr: Сообщение обработано
cb --> cf: Статус сообщения обновлен

end
@enduml
 
Процесс:
1.	Провайдер направляет в Public API коммуникаций запрос на обновление статуса сообщения POST /messages/{messageId}/status
2.	Модуль коммуникаций получает этот запрос, проверяет полученный токен
3.	Модуль коммуникаций производит поиск сообщения в БД сообщений:
1.	Найти сообщение, messageId которого равен t_message.external_id и chatId равен t_message.chat.external_id
4.	Если сообщение найдено, модуль коммуникаций обновляет найденное сообщение:
1.	t_message.delivery_status = новый статус из запроса (delivered, read, failed, cancelled)
5.	Модуль коммуникаций направляет на фронт инфо о том, что сообщение обновлено
Отметка чата как прочитанного
Описание: процесс массового обновления статуса прочтения сообщений в чате, инициированный провайдером. 
@startuml
Participant "Provider" as pr
Participant "Communications.Back" as cb
Database "Communications DB" as cdb
Participant "Communications.Front" as cf

pr -> cb: Пометить все сообщения чата как прочитанные
cb -> cb: Проверка токена

alt Если токен не верный
cb --> pr: Неверный токен
else Если токен верный

cb --> pr: Ok
cb -> cdb: Найти все непрочитанные сообщения чата
cdb --> cb: Ok

loop Для каждого непрочитанного сообщения
cb -> cdb: Сменить статус прочитанности сообщения
cdb --> cb: Ok
end

cb -> cdb: Обнулить счетчик непрочитанных сообщений в чате
cdb --> cb: Ok

cb --> cf: Сообщения прочитаны

end
@enduml

Процесс:
1.	Провайдер направляет в Public API коммуникаций запрос на отметку чата прочитанным POST /chats/{chatId}/seen
2.	Модуль коммуникаций получает этот запрос, проверяет полученный токен
3.	Модуль коммуникаций производит поиск чата в БД чатов:
1.	Найти чат, external_id которого равен chatId
4.	Если чат найден, модуль коммуникаций обновляет все непрочитанные сообщения в этом чате:
1.	t_message.seen_flag = true для всех сообщений
2.	t_chat.unread_messages_count = 0
5.	Модуль коммуникаций возвращает подтверждение об успешном обновлении
Подключение нового канала провайдера
Описание: процесс регистрации нового канала коммуникаций, инициированный провайдером после добавления нового канала пользователем в личном кабинете провайдера. Включает создание или активацию аккаунта в модуле коммуникаций.
@startuml
Participant "Provider" as pr
Participant "Communications.Back" as cb
Database "Communications DB" as cdb
Participant "Communications.Front" as cf

pr -> cb: Подключить канал
cb -> cb: Проверка токена

alt Если токен не верный
cb --> pr: Неверный токен
else Если токен верный

cb -> cdb: Поиск аккаунта в БД

alt Если аккаунта нет
cdb --> cb: Аккаунт не найден
cb -> cdb: Создать и активировать аккаунт
cdb --> cb: Ok
else Если есть неактивный аккаунт
cdb --> cb: Найден неактивный аккаунт
cb -> cdb: Активировать аккаунт
cdb --> cb: Ok
end

cb --> pr: Канал подключен в CRM
cb --> cf: Подключен новый канал

end
@enduml
 
Процесс:
1.	Провайдер направляет в Public API запрос на добавление нового канала коммуникаций POST /channels
2.	Модуль коммуникаций получает этот запрос, проверяет полученный токен
3.	Модуль коммуникаций производит поиск аккаунта в БД аккаунтов:
1.	Найти аккаунт, external_id которого равен channelId
1.	Этот канал должен быть только с типом external
2.	Этот аккаунт должен быть дочерним по отношению к мастер-аккаунту тенанта для этого провайдера
2.	Если такой аккаунт найден - активировать его: t_account.active_flag = true
3.	Если такого аккаунта нет:
1.	Найти в БД каналов канал по его channelCode. Создать канал, если его нет:
1.	t_channel_type.code = channelCode
2.	t_channel_type.label = channelName
3.	t_channel_type.type = external
2.	Создать аккаунт:
1.	t_account.id = присваивается автоматически
2.	t_account.tenant_id = id тенанта, к которому привязан токен в заголовке запроса
3.	t_account.provider_id = id провайдера
4.	t_account.channel_type_code = код канала, код которого равен channelCode или созданного
5.	t_account.parent_account_id = id мастер-аккаунта тенанта у провайдера
6.	t_account.external_id = channelId
7.	t_account.name = name
8.	t_account.active_flag = true
9.	t_account.settings = additionalInfo из запроса
10.	t_account.phone = phone
11.	t_account.email = email
12.	t_account.username = username
3.	Создать запись в t_member для account.self_member_id:
1.	t_member.id = присваивается автоматически
2.	t_member.tenant_id = id тенанта
3.	t_member.account_id = id созданного аккаунта
4.	t_member.external_id = channelId + "_self"
5.	t_member.name = name
6.	t_member.email = email
7.	t_member.phone = phone
8.	t_member.username = username
9.	t_member.client_flag = false
4.	Обновить t_account.self_member_id = id созданного участника
4.	Модуль коммуникаций возвращает подтверждение об успешном добавлении канала
Отключение канала провайдера
Описание: процесс деактивации канала коммуникаций, инициированный провайдером после отключения канала пользователем в личном кабинете провайдера.
@startuml
Participant "Provider" as pr
Participant "Communications.Back" as cb
Database "Communications DB" as cdb
Participant "Communications.Front" as cf

pr -> cb: Отключить канал
cb -> cb: Проверка токена

alt Если токен не верный
cb --> pr: Неверный токен
else Если токен верный

cb -> cdb: Деактивировать аккаунт
cdb --> cb: Ok

cb --> pr: Канал отключен
cb --> cf: Канал отключен

end
@enduml
 
Процесс:
1.	Провайдер направляет в Public API запрос на отключение канала коммуникаций DELETE /channels/{channelId}
2.	Модуль коммуникаций получает этот запрос, проверяет полученный токен
3.	Модуль коммуникаций производит поиск аккаунта в БД аккаунтов:
1.	Найти аккаунт, external_id которого равен channelId
1.	Этот канал должен быть только с типом external
2.	Этот аккаунт должен быть дочерним по отношению к мастер-аккаунту тенанта для этого провайдера
2.	Если аккаунт найден, деактивировать его: t_account.active_flag = false
3.	Пометить все чаты, связанные с этим аккаунтом, как архивные (если такой статус предусмотрен)
4.	Модуль коммуникаций возвращает подтверждение об успешном отключении канала



